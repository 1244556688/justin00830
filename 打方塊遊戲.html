<!DOCTYPE html>
<!-- saved from url=(0033)https://1244556688.github.io/456/ -->
<html lang="zh-TW"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>打方塊遊戲</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: linear-gradient(270deg, #1a2a6c, #b21f1f, #fdbb2d);
    background-size: 600% 600%;
    animation: bgGradient 20s ease infinite;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
  }
  @keyframes bgGradient {
    0% {background-position:0% 50%;}
    50% {background-position:100% 50%;}
    100% {background-position:0% 50%;}
  }
  #gameCanvas {
    display: block;
    margin: 40px auto;
    background: #111;
    border: 3px solid #0ff;
    border-radius: 12px;
    box-shadow: 0 0 30px #0ff;
  }
  #scoreBoard {
    text-align: center;
    font-size: 24px;
    color: #0ff;
    text-shadow: 0 0 8px #0ff;
  }
  #gameOverMessage {
    text-align: center;
    color: #f00;
    font-size: 32px;
    margin-top: 10px;
    text-shadow: 0 0 12px #f00;
    display: none;
  }
  #levelDisplay {
    text-align: center;
    font-size: 20px;
    color: #0ff;
    margin-top: 5px;
    text-shadow: 0 0 6px #0ff;
  }
</style>
</head>
<body>

<canvas id="gameCanvas" width="800" height="500"></canvas>
<div id="scoreBoard">分數: 10</div>
<div id="levelDisplay">關卡: 1</div>
<div id="gameOverMessage" style="display: block;">遊戲結束！按空白鍵重新開始</div>

<!-- 音效 -->
<audio id="brickSound" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>
<audio id="paddleSound" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>
<audio id="gameOverSound" src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg" preload="auto"></audio>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const scoreBoard = document.getElementById('scoreBoard');
  const gameOverMessage = document.getElementById('gameOverMessage');
  const levelDisplay = document.getElementById('levelDisplay');

  const brickSound = document.getElementById('brickSound');
  const paddleSound = document.getElementById('paddleSound');
  const gameOverSound = document.getElementById('gameOverSound');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  // 擋板設定
  const paddleWidth = 120;
  const paddleHeight = 15;
  let paddleX = (WIDTH - paddleWidth) / 2;

  // 球設定
  const ballRadius = 12;
  let ballX;
  let ballY;
  let ballSpeedX;
  let ballSpeedY;

  // 磚塊設定
  const brickRowCount = 5;
  const brickColumnCount = 9;
  const brickWidth = 70;
  const brickHeight = 25;
  const brickPadding = 10;
  const brickOffsetTop = 40;
  const brickOffsetLeft = 35;

  // 分數與關卡
  let score = 0;
  let level = 1;

  // 遊戲狀態
  let gameOver = false;
  let gameWon = false;

  // 建立磚塊陣列
  let bricks = [];

  function createBricks() {
    bricks = [];
    for(let c=0; c<brickColumnCount; c++) {
      bricks[c] = [];
      for(let r=0; r<brickRowCount; r++) {
        bricks[c][r] = { x: 0, y: 0, status: 1 };
      }
    }
  }

  createBricks();

  // 監聽滑鼠移動，控制擋板
  document.addEventListener('mousemove', mouseMoveHandler, false);
  function mouseMoveHandler(e) {
    const rect = canvas.getBoundingClientRect();
    let relativeX = e.clientX - rect.left;
    if(relativeX > 0 && relativeX < WIDTH) {
      paddleX = relativeX - paddleWidth / 2;
      if(paddleX < 0) paddleX = 0;
      if(paddleX + paddleWidth > WIDTH) paddleX = WIDTH - paddleWidth;
    }
  }

  // 監聽按鍵重新開始
  document.addEventListener('keydown', e => {
    if(e.code === 'Space' && (gameOver || gameWon)) {
      resetGame();
    }
  });

  // 重置遊戲（包含關卡）
  function resetGame() {
    gameOver = false;
    gameWon = false;
    score = 0;
    level = 1;
    levelDisplay.textContent = '關卡: ' + level;
    scoreBoard.textContent = '分數: 0';
    gameOverMessage.style.display = 'none';

    createBricks();
    resetBallAndPaddle();

    draw();
    requestAnimationFrame(gameLoop);
  }

  // 重置球與擋板位置及速度（根據關卡調整球速）
  function resetBallAndPaddle() {
    ballX = WIDTH / 2;
    ballY = HEIGHT - 50;
    // 球速隨關卡增加
    const baseSpeed = 5;
    ballSpeedX = baseSpeed * level * (Math.random() > 0.5 ? 1 : -1);
    ballSpeedY = -baseSpeed * level;
    paddleX = (WIDTH - paddleWidth) / 2;
  }

  // 繪製磚塊
  function drawBricks() {
    for(let c=0; c<brickColumnCount; c++) {
      for(let r=0; r<brickRowCount; r++) {
        if(bricks[c][r].status === 1) {
          let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
          let brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
          bricks[c][r].x = brickX;
          bricks[c][r].y = brickY;
          // 漸層色塊，彩虹色效果，隨關卡變化亮度
          const baseColors = ['#ff3c3c','#ff963c','#fff53c','#3cff68','#3cfcff','#3c6eff','#9b3cff'];
          let colorIndex = r % baseColors.length;
          // 變亮度
          let baseColor = baseColors[colorIndex];
          ctx.fillStyle = adjustColorBrightness(baseColor, level * 10);
          ctx.fillRect(brickX, brickY, brickWidth, brickHeight);
          ctx.strokeStyle = '#000';
          ctx.strokeRect(brickX, brickY, brickWidth, brickHeight);
        }
      }
    }
  }

  // 調整顏色亮度的輔助函數
  function adjustColorBrightness(hexColor, percent) {
    // hexColor 格式：#RRGGBB
    let r = parseInt(hexColor.substr(1,2), 16);
    let g = parseInt(hexColor.substr(3,2), 16);
    let b = parseInt(hexColor.substr(5,2), 16);

    r = Math.min(255, r + percent);
    g = Math.min(255, g + percent);
    b = Math.min(255, b + percent);

    return `rgb(${r},${g},${b})`;
  }

  // 繪製擋板
  function drawPaddle() {
    let grad = ctx.createLinearGradient(paddleX, HEIGHT - paddleHeight - 10, paddleX + 

paddleWidth, HEIGHT - 10);
    grad.addColorStop(0, '#0ff');
    grad.addColorStop(1, '#06f');
    ctx.fillStyle = grad;
    ctx.shadowColor = '#0ff';
    ctx.shadowBlur = 10;
    ctx.fillRect(paddleX, HEIGHT - paddleHeight - 10, paddleWidth, paddleHeight);
    ctx.shadowBlur = 0;
  }

  // 繪製球
  function drawBall() {
    let grad = ctx.createRadialGradient(ballX + ballRadius/2, ballY + ballRadius/2, ballRadius/3, ballX 

+ ballRadius/2, ballY + ballRadius/2, ballRadius);
    grad.addColorStop(0, '#0ff');
    grad.addColorStop(1, '#003344');
    ctx.fillStyle = grad;
    ctx.shadowColor = '#0ff';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.closePath();
    ctx.shadowBlur = 0;
  }

  // 碰撞偵測：球與磚塊
  function collisionDetection() {
    for(let c=0; c<brickColumnCount; c++) {
      for(let r=0; r<brickRowCount; r++) {
        let b = bricks[c][r];
        if(b.status === 1) {
          if(
            ballX > b.x &&
            ballX < b.x + brickWidth &&
            ballY > b.y &&
            ballY < b.y + brickHeight
          ) {
            ballSpeedY = -ballSpeedY;
            b.status = 0;
            score += 10;
            scoreBoard.textContent = '分數: ' + score;

            brickSound.currentTime = 0;
            brickSound.play();

            // 判斷是否過關
            if(score === brickRowCount * brickColumnCount * 10 * level) {
              levelUp();
            }
          }
        }
      }
    }
  }

  // 過關
  function levelUp() {
    level++;
    levelDisplay.textContent = '關卡: ' + level;
    gameWon = false;
    scoreBoard.textContent = '分數: ' + score;
    createBricks();
    resetBallAndPaddle();
  }

  // 清除畫面
  function clear() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
  }

  // 繪製所有遊戲元素
  function draw() {
    clear();
    drawBricks();
    drawPaddle();
    drawBall();
  }

  // 遊戲主循環
  function gameLoop() {
    if(gameOver) return;

    ballX += ballSpeedX;
    ballY += ballSpeedY;

    // 碰牆反彈
    if(ballX + ballRadius > WIDTH) {
      ballX = WIDTH - ballRadius;
      ballSpeedX = -ballSpeedX;
    }
    if(ballX - ballRadius < 0) {
      ballX = ballRadius;
      ballSpeedX = -ballSpeedX;
    }
    if(ballY - ballRadius < 0) {
      ballY = ballRadius;
      ballSpeedY = -ballSpeedY;
    }
    // 球碰擋板
    if(ballY + ballRadius > HEIGHT - paddleHeight - 10) {
      if(ballX > paddleX && ballX < paddleX + paddleWidth) {
        ballY = HEIGHT - paddleHeight - 10 - ballRadius;
        ballSpeedY = -ballSpeedY;

        // 擋板接球後，改變水平速度，越接近邊緣越大角度
        let hitPos = (ballX - (paddleX + paddleWidth / 2)) / (paddleWidth / 2);
        ballSpeedX = hitPos * 8;

        paddleSound.currentTime = 0;
        paddleSound.play();
      } else if(ballY + ballRadius > HEIGHT) {
        gameOver = true;
        gameOverMessage.textContent = '遊戲結束！按空白鍵重新開始';
        gameOverMessage.style.display = 'block';

        gameOverSound.currentTime = 0;
        gameOverSound.play();
      }
    }

    collisionDetection();
    draw();
    requestAnimationFrame(gameLoop);
  }

  resetGame();
</script>



</body></html>